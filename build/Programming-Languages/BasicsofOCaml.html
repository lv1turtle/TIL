<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Statement and expressions: | Today I Learned</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/TIL/logo.png">
    <meta name="description" content="Today I Learned">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.7abb38d6.css" as="style"><link rel="preload" href="/TIL/assets/js/app.c6f3fbef.js" as="script"><link rel="preload" href="/TIL/assets/js/2.617ccbf7.js" as="script"><link rel="preload" href="/TIL/assets/js/11.507d5eff.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.c93e64e5.js"><link rel="prefetch" href="/TIL/assets/js/12.6be0c16d.js"><link rel="prefetch" href="/TIL/assets/js/13.f17cd59b.js"><link rel="prefetch" href="/TIL/assets/js/14.9cb1a7c6.js"><link rel="prefetch" href="/TIL/assets/js/15.dc3954e7.js"><link rel="prefetch" href="/TIL/assets/js/16.de86639d.js"><link rel="prefetch" href="/TIL/assets/js/17.b7b1166a.js"><link rel="prefetch" href="/TIL/assets/js/3.9f5f5c44.js"><link rel="prefetch" href="/TIL/assets/js/4.4aed992c.js"><link rel="prefetch" href="/TIL/assets/js/5.1e05fed5.js"><link rel="prefetch" href="/TIL/assets/js/6.1333bc3f.js"><link rel="prefetch" href="/TIL/assets/js/7.7b82422e.js"><link rel="prefetch" href="/TIL/assets/js/8.50c3c84b.js"><link rel="prefetch" href="/TIL/assets/js/9.0bd48c5f.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.7abb38d6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today I Learned</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lv1turtle/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://lv1turtle.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lv1turtle/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://lv1turtle.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Monthly I Learned</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Daily Coding</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Data structure and Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Programming-Language</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/Programming-Languages/Inductive_Definition(1).html" class="sidebar-link">Inductive Definition(1)</a></li><li><a href="/TIL/Programming-Languages/Inductive_Definition(2).html" class="sidebar-link">Inductive Definition(2)</a></li><li><a href="/TIL/Programming-Languages/BasicsofOCaml.html" aria-current="page" class="active sidebar-link">Statement and expressions:</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#statement-and-expressions" class="sidebar-link">Statement and expressions:</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#boolean-expression" class="sidebar-link">Boolean Expression :</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#static-types-and-dynamic-types" class="sidebar-link">Static Types and Dynamic Types</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#conversion-between-different-types" class="sidebar-link">Conversion between Different Types</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#conditional-expressions" class="sidebar-link">Conditional Expressions</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#names-and-functions" class="sidebar-link">Names and Functions</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#functions" class="sidebar-link">Functions</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#functions-are-first-class-in-ocaml" class="sidebar-link">Functions are First-Class in OCaml</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#pattern-matching" class="sidebar-link">Pattern Matching</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#type-inference" class="sidebar-link">Type Inference</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#polymorphic-types" class="sidebar-link">Polymorphic Types</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#tuples" class="sidebar-link">Tuples</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#lists" class="sidebar-link">Lists</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#data-types" class="sidebar-link">Data Types</a></li><li class="sidebar-sub-header"><a href="/TIL/Programming-Languages/BasicsofOCaml.html#exceptions" class="sidebar-link">Exceptions</a></li></ul></li><li><a href="/TIL/Programming-Languages/RecursiveandHigher-OrderProgramming(1).html" class="sidebar-link">Recursive / Higher-Order Programming(1)</a></li><li><a href="/TIL/Programming-Languages/RecursiveandHigher-OrderProgramming(2).html" class="sidebar-link">Recursive / Higher-Order Programming(2)</a></li><li><a href="/TIL/Programming-Languages/Designandimplementation.html" class="sidebar-link">Design and implementation</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="statement-and-expressions"><a href="#statement-and-expressions" class="header-anchor">#</a> Statement and expressions:</h2> <ul><li>statement oriented : C, C++, etc (imperative languages)</li> <li>expression oriented : ML, Scala, etc (functional languages)</li></ul> <h2 id="boolean-expression"><a href="#boolean-expression" class="header-anchor">#</a> Boolean Expression :</h2> <ul><li>헷갈릴 만한 요소<br> a &lt;&gt; b : true if <B>a</B> and <B>b</B> are not equal (a = b의 반대)</li></ul> <h2 id="static-types-and-dynamic-types"><a href="#static-types-and-dynamic-types" class="header-anchor">#</a> Static Types and Dynamic Types</h2> <ul><li><p>Statically typed languages : C, C++, java, ML, Scala, etc<br><br> <B>type checking</B>을 컴파일 시에 진행한다.<br> 일반적으로 변수 생성 시에 자료형을 지정해주고 고정이 되므로 컴파일 시간에 자료형 검사가 가능하다.<br></p> <ul><li>type-safe langauages : ML, Haskell, Scala<br> 모든 type error가 컴파일 시간에 검출이 되므로 Compile이 실패하지않음.</li> <li>Unsafe langauages : C, C++<br> guarantee가 보장되지않음, type에 따라 run-time까지 error가 남아있는 경우가 있음.</li></ul></li> <li><p>Dynamically typed languages : Python, JavaScript, Ruby, etc<br><br> <B>type checking</B>을 run-time시에 진행한다.<br> 변수가 모든 자료형을 다 가질 수 있으므로 run-time에서 변수에 대한 자료형을 결정하므로 run-time시에 자료형 검사를 하는 것이 적합하다.</p></li> <li><p>단점 :</p> <ul><li>Statically typed languages : less flexible(상대적으로 유연하지 못함)</li> <li>Dynamically typed languages : Type error가 run-time시에 검출된다는 것</li></ul></li></ul> <h2 id="conversion-between-different-types"><a href="#conversion-between-different-types" class="header-anchor">#</a> Conversion between Different Types</h2> <ul><li><p>OCaml에서 3 + 2.0과 같이 다른 type끼리의 연산은 error</p></li> <li><p>OCaml은 6개의 primitive values를 제공 : integers, booleans, floating point number, characters, strings, unit</p></li></ul> <h2 id="conditional-expressions"><a href="#conditional-expressions" class="header-anchor">#</a> Conditional Expressions</h2> <ul><li>If <B>be</B> then <B>e1</B> else <B>e2</B> <ul><li>be는 boolean expression이여야만 한다. (1,0 불가능)</li> <li>e1, e2의 type은 반드시 동일해야한다. (int, boolean 불가능)</li></ul></li></ul> <h2 id="names-and-functions"><a href="#names-and-functions" class="header-anchor">#</a> Names and Functions</h2> <ul><li><p>(input)# let x = 3 + 4;;<br>(output) val x : int = 7 <br> 이를 A variable x is <B>bound to value</B> 7이라 한다.</p></li> <li><p>let x = e1 in e2</p> <ul><li><p>여기서 x는 x is bound to the value of e1 (즉, x의 값은 e1)</p></li> <li><p>여기서 e2는 이 표현식 전체의 value를 의미 (즉, e2의 결과가 output이 됨)</p></li> <li><p>ex) # let d = let a = 1 in let be = a + a in let c = b + b in c + c;;<br> val d : int = 8</p></li></ul></li></ul> <h2 id="functions"><a href="#functions" class="header-anchor">#</a> Functions</h2> <ul><li><p>let square x = x * x;; (이런 식으로 함수를 만들 수 있음)<br> val square : int -&gt; int = &lt; fun &gt;<br> # square 2;; -&gt; (int 4)</p></li> <li><p>let neg x = if x &lt; 0 then true else false;; (함수의 표현은 자유로운 편) <br> val neg : int -&gt; bool = &lt; fun &gt;</p></li> <li><p>let sum_of_squares x y = (square x) + (square y);; (multiple argument도 가능)</p></li> <li><p>let rec factorical a = if a = 1 then 1 else a * factorial (a-1);;<br> <B>let rec</B>을 사용하여 recursive 가능</p></li> <li><p>함수에 이름 지정하지 않아도 생성 가능 # (fun x -&gt; x * x) 2;;</p></li> <li><p>let square = fun x -&gt; x * x (이런 식으로 function에 bound 가능)</p></li></ul> <h2 id="functions-are-first-class-in-ocaml"><a href="#functions-are-first-class-in-ocaml" class="header-anchor">#</a> Functions are First-Class in OCaml</h2> <ul><li><p>아래 조건들을 만족하면 그 value는 first class에 속한다고 한다.</p> <ul><li><B>stored in a variable </B> <ul><li>let square = fun x -&gt; x * x;; (만족)</li></ul></li> <li><B>passed as an argument of a function</B> <ul><li>let sum_if_true test first second = (if test first then first else 0) + (if test second then second else 0);;</li> <li>val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt; fun &gt;</li> <li>let even x = x mod 2 = 0;; (int -&gt; bool, 즉 test에는 int를 입력받아서 bool값을 출력하는 함수가 들어감)</li> <li>sum_if_true even 3 4;; (이로써 functions can be passed to other functions을 확인)</li></ul></li> <li><B>ruturned from other functions</B> <ul><li>let plus_a a = fun b -&gt; a + b;;<br># let f = plus_a 3;;<br> # f 1;;</li> <li>다른 함수(f)에 의해 plus_a(함수)가 return 되었으므로 만족</li></ul></li></ul> <p>이런 manipulate function을 <B>higher-order functions</B>이라 한다.</p></li> <li><p>따라서 OCaml에서 function은 First class에 속하며, 이런 language를 <B>functional</B>이라 한다.</p> <ul><li>e,g.) ML, Scala, Python, etc</li></ul></li></ul> <h2 id="pattern-matching"><a href="#pattern-matching" class="header-anchor">#</a> Pattern Matching</h2> <ul><li><p>match <B>x</B> with (x는 variable)을 사용하여 pattern matching 기법 사용</p></li> <li><p>let rec factorial a = if a = 1 then 1 else a * factorial (a - 1)을 아래와 같이 elegant한 방법으로 쓸 수 있음<br> <B>let factorial a = match a with 1 -&gt; 1 | _ -&gt; a * factorial (a - 1)</B></p></li> <li><h5 id="e-g-let-isabc-c-match-c-with-a-b-c-true-false"><a href="#e-g-let-isabc-c-match-c-with-a-b-c-true-false" class="header-anchor">#</a> e.g.) let isabc c = match c with 'a' | 'b' | 'c' -&gt; true | _ -&gt; false</h5></li></ul> <h2 id="type-inference"><a href="#type-inference" class="header-anchor">#</a> Type Inference</h2> <ul><li><p>C나 Java와 다르게 type 선언을 할 필요가 없음 (OCaml은 알아서 유추함)</p></li> <li><p>원하면 type 선언도 가능</p> <ul><li>let sum_if_true (test : int -&gt; bool) (x : int) (y : int) : int = (if test x then x else 0) + (if test y then y else 0);;</li></ul></li></ul> <h2 id="polymorphic-types"><a href="#polymorphic-types" class="header-anchor">#</a> Polymorphic Types</h2> <ul><li><p>let id x = x;;를 하면 입력한 value의 type을 알 수 있음</p> <ul><li>val id : 'a -&gt; 'a = &lt; fun &gt;</li> <li>e.g.) id &quot;abc&quot;;; -&gt; string = &quot;abc&quot;</li></ul></li> <li><p>이러한 function을 <B>polymorphic</B>이라 하며 여기서 <B>'a</B>는 type variable이다.</p></li> <li><p>Quiz) let first_if_true test x y = if test x then x else y;;</p> <ul><li>Answer) val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt; fun &gt;</li></ul></li></ul> <h2 id="tuples"><a href="#tuples" class="header-anchor">#</a> Tuples</h2> <ul><li><p>let x = (1, &quot;one&quot;);;<br> val x : int * string = (1,&quot;one&quot;)</p></li> <li><p>let fst p = match p with (x,_) -&gt; x;;<br> val fst : 'a * 'b -&gt; 'a = &lt; fun &gt;</p></li> <li><p>이런 것도 가능 # let p  = (1,true);;<br>#let (x,y) = p;;<br>val x : int = 1 val y : bool = true</p></li></ul> <h2 id="lists"><a href="#lists" class="header-anchor">#</a> Lists</h2> <ul><li><p>list의 elements들은 모두 같은 type이여야만 한다.</p></li> <li><p>elements 간의 순서가 있다. e.g. [1; 2; 3] &lt;&gt; [2; 3; 1]</p></li> <li><p>first element : head, last element : tail이라 부른다.</p></li> <li><p>Quiz</p> <ul><li>[] : the empty list, what are head and tail of []?<br> NULL</li> <li>[5] : head and tail<br>5</li></ul></li> <li><p>ex) # [[1; 2; 3]; [2; 3; 4]];;<br> int list list = [[1; 2; 3]; [2; 3; 4]]</p></li> <li><p>:: (cons), 일명 cons라 불리는 &quot;::&quot;기호는 list에 single element를 더해주는 operator.</p> <ul><li>1::[2; 3];; =&gt; [1; 2; 3]</li> <li>1::2::3::[];; =&gt; [1; 2; 3]</li></ul></li> <li><p>@ (append), &quot;@&quot; operator는 두 list를 결합한다.</p> <ul><li>[1; 2] @ [3; 4; 5];; =&gt; [1; 2; 3; 4; 5]</li></ul></li> <li><p>Pattern matching에도 가능<br>
let isnil l = <B>match l with []</B> -&gt; true | _ -&gt; false ;;</p> <ul><li>val isnil : 'a list -&gt; bool = &lt; fun &gt;</li> <li>isnil [1];; =&gt; false, isnil [];; =&gt; true (list가 비어있을때 true를 반환)</li></ul> <p>이렇게도 가능<br>
let rec length l = match l with [] -&gt; 0 | h::t -&gt; 1 + length t;;<br>
let rec length l = match l with [] -&gt; 0 | _::t -&gt; 1 + length t;;(same)</p> <ul><li>length [1; 2; 3];; =&gt; int = 3</li></ul></li></ul> <h2 id="data-types"><a href="#data-types" class="header-anchor">#</a> Data Types</h2> <ul><li><p>OCaml에서는 data type을 선언할 수도 있다.
types days = Mon | Tue | Wed | Thu | Fri;; (days라는 타입과 그 element들이 선언되었다.)</p> <ul><li>Mon;; =&gt; days = Mon</li></ul> <p>let nextday d = match d with | Mon -&gt; Tue | Tue -&gt; Wed | Wed -&gt; Thu | Thu -&gt; Fri | Fri -&gt; Mon ;;</p> <ul><li>nextday Mon;; =&gt; days = Tue</li></ul> <h4 id="type-shape-rect-of-int-int-circle-of-int-type-내부에-type을-선언-가능"><a href="#type-shape-rect-of-int-int-circle-of-int-type-내부에-type을-선언-가능" class="header-anchor">#</a> type shape = Rect of int * int | Circle of int;; ( type 내부에 type을 선언 가능 )</h4> <p>let area s = match s with Rect (w,h) -&gt; w * h | Circle r -&gt; r * r * 3;;</p> <ul><li>area (Rect (2,3));; =&gt; int = 6</li> <li>area (Circle 5);; =&gt; int = 75</li></ul> <p>type mylist = Nil | List of int * mylist;;</p> <ul><li>List (1, List (2, Nil));;</li></ul> <p>(재귀)<br>
let rec mylength l = match l with Nil -&gt; 0 | List (_,l') -&gt; 1 + mylength l';;</p> <ul><li>mylength (List (1, List (2, Nil)));;<br> int = 2</li></ul></li></ul> <h2 id="exceptions"><a href="#exceptions" class="header-anchor">#</a> Exceptions</h2> <ul><li><p>exception은 run-time error를 의미한다.</p> <ul><li>ex) let div a b = a / b;; <br> div 10 0;;<br>(Exception: Division_by_zero)</li></ul></li> <li><p>이를 다룰 수 있음.</p> <ul><li>let div a b = <B>try a/b with Division_by_zero -&gt; 0;;</B></li> <li>div 10 0;; (int = 0)</li></ul></li> <li><p>직접 exception problem을 정의 가능</p> <ul><li>let div a b = if b = 0 then <B>raise Problem</B> else a / b;;</li> <li>div 10 0;; (Exception: Problem)</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/TIL/Programming-Languages/Inductive_Definition(2).html" class="prev">
        Inductive Definition(2)
      </a></span> <span class="next"><a href="/TIL/Programming-Languages/RecursiveandHigher-OrderProgramming(1).html">
        Recursive / Higher-Order Programming(1)
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.c6f3fbef.js" defer></script><script src="/TIL/assets/js/2.617ccbf7.js" defer></script><script src="/TIL/assets/js/11.507d5eff.js" defer></script>
  </body>
</html>
