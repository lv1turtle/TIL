(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{464:function(t,e,a){"use strict";a.r(e);var i=a(65),l=Object(i.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"statement-and-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#statement-and-expressions"}},[t._v("#")]),t._v(" Statement and expressions:")]),t._v(" "),a("ul",[a("li",[t._v("statement oriented : C, C++, etc (imperative languages)")]),t._v(" "),a("li",[t._v("expression oriented : ML, Scala, etc (functional languages)")])]),t._v(" "),a("h2",{attrs:{id:"boolean-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#boolean-expression"}},[t._v("#")]),t._v(" Boolean Expression :")]),t._v(" "),a("ul",[a("li",[t._v("헷갈릴 만한 요소"),a("br"),t._v(" a <> b : true if "),a("B",[t._v("a")]),t._v(" and "),a("B",[t._v("b")]),t._v(" are not equal (a = b의 반대)")],1)]),t._v(" "),a("h2",{attrs:{id:"static-types-and-dynamic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-types-and-dynamic-types"}},[t._v("#")]),t._v(" Static Types and Dynamic Types")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Statically typed languages : C, C++, java, ML, Scala, etc"),a("br"),a("br"),t._v(" "),a("B",[t._v("type checking")]),t._v("을 컴파일 시에 진행한다."),a("br"),t._v(" 일반적으로 변수 생성 시에 자료형을 지정해주고 고정이 되므로 컴파일 시간에 자료형 검사가 가능하다."),a("br")],1),t._v(" "),a("ul",[a("li",[t._v("type-safe langauages : ML, Haskell, Scala"),a("br"),t._v(" 모든 type error가 컴파일 시간에 검출이 되므로 Compile이 실패하지않음.")]),t._v(" "),a("li",[t._v("Unsafe langauages : C, C++"),a("br"),t._v(" guarantee가 보장되지않음, type에 따라 run-time까지 error가 남아있는 경우가 있음.")])])]),t._v(" "),a("li",[a("p",[t._v("Dynamically typed languages : Python, JavaScript, Ruby, etc"),a("br"),a("br"),t._v(" "),a("B",[t._v("type checking")]),t._v("을 run-time시에 진행한다."),a("br"),t._v(" 변수가 모든 자료형을 다 가질 수 있으므로 run-time에서 변수에 대한 자료형을 결정하므로 run-time시에 자료형 검사를 하는 것이 적합하다.")],1)]),t._v(" "),a("li",[a("p",[t._v("단점 :")]),t._v(" "),a("ul",[a("li",[t._v("Statically typed languages : less flexible(상대적으로 유연하지 못함)")]),t._v(" "),a("li",[t._v("Dynamically typed languages : Type error가 run-time시에 검출된다는 것")])])])]),t._v(" "),a("h2",{attrs:{id:"conversion-between-different-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conversion-between-different-types"}},[t._v("#")]),t._v(" Conversion between Different Types")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("OCaml에서 3 + 2.0과 같이 다른 type끼리의 연산은 error")])]),t._v(" "),a("li",[a("p",[t._v("OCaml은 6개의 primitive values를 제공 : integers, booleans, floating point number, characters, strings, unit")])])]),t._v(" "),a("h2",{attrs:{id:"conditional-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conditional-expressions"}},[t._v("#")]),t._v(" Conditional Expressions")]),t._v(" "),a("ul",[a("li",[t._v("If "),a("B",[t._v("be")]),t._v(" then "),a("B",[t._v("e1")]),t._v(" else "),a("B",[t._v("e2")]),t._v(" "),a("ul",[a("li",[t._v("be는 boolean expression이여야만 한다. (1,0 불가능)")]),t._v(" "),a("li",[t._v("e1, e2의 type은 반드시 동일해야한다. (int, boolean 불가능)")])])],1)]),t._v(" "),a("h2",{attrs:{id:"names-and-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#names-and-functions"}},[t._v("#")]),t._v(" Names and Functions")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("(input)# let x = 3 + 4;;"),a("br"),t._v("(output) val x : int = 7 "),a("br"),t._v(" 이를 A variable x is "),a("B",[t._v("bound to value")]),t._v(" 7이라 한다.")],1)]),t._v(" "),a("li",[a("p",[t._v("let x = e1 in e2")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("여기서 x는 x is bound to the value of e1 (즉, x의 값은 e1)")])]),t._v(" "),a("li",[a("p",[t._v("여기서 e2는 이 표현식 전체의 value를 의미 (즉, e2의 결과가 output이 됨)")])]),t._v(" "),a("li",[a("p",[t._v("ex) # let d = let a = 1 in let be = a + a in let c = b + b in c + c;;"),a("br"),t._v(" val d : int = 8")])])])])]),t._v(" "),a("h2",{attrs:{id:"functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[t._v("#")]),t._v(" Functions")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("let square x = x * x;; (이런 식으로 함수를 만들 수 있음)"),a("br"),t._v(" val square : int -> int = < fun >"),a("br"),t._v(" # square 2;; -> (int 4)")])]),t._v(" "),a("li",[a("p",[t._v("let neg x = if x < 0 then true else false;; (함수의 표현은 자유로운 편) "),a("br"),t._v(" val neg : int -> bool = < fun >")])]),t._v(" "),a("li",[a("p",[t._v("let sum_of_squares x y = (square x) + (square y);; (multiple argument도 가능)")])]),t._v(" "),a("li",[a("p",[t._v("let rec factorical a = if a = 1 then 1 else a * factorial (a-1);;"),a("br"),t._v(" "),a("B",[t._v("let rec")]),t._v("을 사용하여 recursive 가능")],1)]),t._v(" "),a("li",[a("p",[t._v("함수에 이름 지정하지 않아도 생성 가능 # (fun x -> x * x) 2;;")])]),t._v(" "),a("li",[a("p",[t._v("let square = fun x -> x * x (이런 식으로 function에 bound 가능)")])])]),t._v(" "),a("h2",{attrs:{id:"functions-are-first-class-in-ocaml"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functions-are-first-class-in-ocaml"}},[t._v("#")]),t._v(" Functions are First-Class in OCaml")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("아래 조건들을 만족하면 그 value는 first class에 속한다고 한다.")]),t._v(" "),a("ul",[a("li",[a("B",[t._v("stored in a variable ")]),t._v(" "),a("ul",[a("li",[t._v("let square = fun x -> x * x;; (만족)")])])],1),t._v(" "),a("li",[a("B",[t._v("passed as an argument of a function")]),t._v(" "),a("ul",[a("li",[t._v("let sum_if_true test first second = (if test first then first else 0) + (if test second then second else 0);;")]),t._v(" "),a("li",[t._v("val sum_if_true : (int -> bool) -> int -> int -> int = < fun >")]),t._v(" "),a("li",[t._v("let even x = x mod 2 = 0;; (int -> bool, 즉 test에는 int를 입력받아서 bool값을 출력하는 함수가 들어감)")]),t._v(" "),a("li",[t._v("sum_if_true even 3 4;; (이로써 functions can be passed to other functions을 확인)")])])],1),t._v(" "),a("li",[a("B",[t._v("ruturned from other functions")]),t._v(" "),a("ul",[a("li",[t._v("let plus_a a = fun b -> a + b;;"),a("br"),t._v("# let f = plus_a 3;;"),a("br"),t._v(" # f 1;;")]),t._v(" "),a("li",[t._v("다른 함수(f)에 의해 plus_a(함수)가 return 되었으므로 만족")])])],1)]),t._v(" "),a("p",[t._v("이런 manipulate function을 "),a("B",[t._v("higher-order functions")]),t._v("이라 한다.")],1)]),t._v(" "),a("li",[a("p",[t._v("따라서 OCaml에서 function은 First class에 속하며, 이런 language를 "),a("B",[t._v("functional")]),t._v("이라 한다.")],1),t._v(" "),a("ul",[a("li",[t._v("e,g.) ML, Scala, Python, etc")])])])]),t._v(" "),a("h2",{attrs:{id:"pattern-matching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pattern-matching"}},[t._v("#")]),t._v(" Pattern Matching")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("match "),a("B",[t._v("x")]),t._v(" with (x는 variable)을 사용하여 pattern matching 기법 사용")],1)]),t._v(" "),a("li",[a("p",[t._v("let rec factorial a = if a = 1 then 1 else a * factorial (a - 1)을 아래와 같이 elegant한 방법으로 쓸 수 있음"),a("br"),t._v(" "),a("B",[t._v("let factorial a = match a with 1 -> 1 | _ -> a * factorial (a - 1)")])],1)]),t._v(" "),a("li",[a("h5",{attrs:{id:"e-g-let-isabc-c-match-c-with-a-b-c-true-false"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#e-g-let-isabc-c-match-c-with-a-b-c-true-false"}},[t._v("#")]),t._v(" e.g.) let isabc c = match c with 'a' | 'b' | 'c' -> true | _ -> false")])])]),t._v(" "),a("h2",{attrs:{id:"type-inference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-inference"}},[t._v("#")]),t._v(" Type Inference")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("C나 Java와 다르게 type 선언을 할 필요가 없음 (OCaml은 알아서 유추함)")])]),t._v(" "),a("li",[a("p",[t._v("원하면 type 선언도 가능")]),t._v(" "),a("ul",[a("li",[t._v("let sum_if_true (test : int -> bool) (x : int) (y : int) : int = (if test x then x else 0) + (if test y then y else 0);;")])])])]),t._v(" "),a("h2",{attrs:{id:"polymorphic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#polymorphic-types"}},[t._v("#")]),t._v(" Polymorphic Types")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("let id x = x;;를 하면 입력한 value의 type을 알 수 있음")]),t._v(" "),a("ul",[a("li",[t._v("val id : 'a -> 'a = < fun >")]),t._v(" "),a("li",[t._v('e.g.) id "abc";; -> string = "abc"')])])]),t._v(" "),a("li",[a("p",[t._v("이러한 function을 "),a("B",[t._v("polymorphic")]),t._v("이라 하며 여기서 "),a("B",[t._v("'a")]),t._v("는 type variable이다.")],1)]),t._v(" "),a("li",[a("p",[t._v("Quiz) let first_if_true test x y = if test x then x else y;;")]),t._v(" "),a("ul",[a("li",[t._v("Answer) val first_if_true : ('a -> bool) -> 'a -> 'a -> 'a = < fun >")])])])]),t._v(" "),a("h2",{attrs:{id:"tuples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tuples"}},[t._v("#")]),t._v(" Tuples")]),t._v(" "),a("ul",[a("li",[a("p",[t._v('let x = (1, "one");;'),a("br"),t._v(' val x : int * string = (1,"one")')])]),t._v(" "),a("li",[a("p",[t._v("let fst p = match p with (x,_) -> x;;"),a("br"),t._v(" val fst : 'a * 'b -> 'a = < fun >")])]),t._v(" "),a("li",[a("p",[t._v("이런 것도 가능 # let p  = (1,true);;"),a("br"),t._v("#let (x,y) = p;;"),a("br"),t._v("val x : int = 1 val y : bool = true")])])]),t._v(" "),a("h2",{attrs:{id:"lists"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lists"}},[t._v("#")]),t._v(" Lists")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("list의 elements들은 모두 같은 type이여야만 한다.")])]),t._v(" "),a("li",[a("p",[t._v("elements 간의 순서가 있다. e.g. [1; 2; 3] <> [2; 3; 1]")])]),t._v(" "),a("li",[a("p",[t._v("first element : head, last element : tail이라 부른다.")])]),t._v(" "),a("li",[a("p",[t._v("Quiz")]),t._v(" "),a("ul",[a("li",[t._v("[] : the empty list, what are head and tail of []?"),a("br"),t._v(" NULL")]),t._v(" "),a("li",[t._v("[5] : head and tail"),a("br"),t._v("5")])])]),t._v(" "),a("li",[a("p",[t._v("ex) # [[1; 2; 3]; [2; 3; 4]];;"),a("br"),t._v(" int list list = [[1; 2; 3]; [2; 3; 4]]")])]),t._v(" "),a("li",[a("p",[t._v(':: (cons), 일명 cons라 불리는 "::"기호는 list에 single element를 더해주는 operator.')]),t._v(" "),a("ul",[a("li",[t._v("1::[2; 3];; => [1; 2; 3]")]),t._v(" "),a("li",[t._v("1::2::3::[];; => [1; 2; 3]")])])]),t._v(" "),a("li",[a("p",[t._v('@ (append), "@" operator는 두 list를 결합한다.')]),t._v(" "),a("ul",[a("li",[t._v("[1; 2] @ [3; 4; 5];; => [1; 2; 3; 4; 5]")])])]),t._v(" "),a("li",[a("p",[t._v("Pattern matching에도 가능"),a("br"),t._v("\nlet isnil l = "),a("B",[t._v("match l with []")]),t._v(" -> true | _ -> false ;;")],1),t._v(" "),a("ul",[a("li",[t._v("val isnil : 'a list -> bool = < fun >")]),t._v(" "),a("li",[t._v("isnil [1];; => false, isnil [];; => true (list가 비어있을때 true를 반환)")])]),t._v(" "),a("p",[t._v("이렇게도 가능"),a("br"),t._v("\nlet rec length l = match l with [] -> 0 | h::t -> 1 + length t;;"),a("br"),t._v("\nlet rec length l = match l with [] -> 0 | _::t -> 1 + length t;;(same)")]),t._v(" "),a("ul",[a("li",[t._v("length [1; 2; 3];; => int = 3")])])])]),t._v(" "),a("h2",{attrs:{id:"data-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[t._v("#")]),t._v(" Data Types")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("OCaml에서는 data type을 선언할 수도 있다.\ntypes days = Mon | Tue | Wed | Thu | Fri;; (days라는 타입과 그 element들이 선언되었다.)")]),t._v(" "),a("ul",[a("li",[t._v("Mon;; => days = Mon")])]),t._v(" "),a("p",[t._v("let nextday d = match d with | Mon -> Tue | Tue -> Wed | Wed -> Thu | Thu -> Fri | Fri -> Mon ;;")]),t._v(" "),a("ul",[a("li",[t._v("nextday Mon;; => days = Tue")])]),t._v(" "),a("h4",{attrs:{id:"type-shape-rect-of-int-int-circle-of-int-type-내부에-type을-선언-가능"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-shape-rect-of-int-int-circle-of-int-type-내부에-type을-선언-가능"}},[t._v("#")]),t._v(" type shape = Rect of int * int | Circle of int;; ( type 내부에 type을 선언 가능 )")]),t._v(" "),a("p",[t._v("let area s = match s with Rect (w,h) -> w * h | Circle r -> r * r * 3;;")]),t._v(" "),a("ul",[a("li",[t._v("area (Rect (2,3));; => int = 6")]),t._v(" "),a("li",[t._v("area (Circle 5);; => int = 75")])]),t._v(" "),a("p",[t._v("type mylist = Nil | List of int * mylist;;")]),t._v(" "),a("ul",[a("li",[t._v("List (1, List (2, Nil));;")])]),t._v(" "),a("p",[t._v("(재귀)"),a("br"),t._v("\nlet rec mylength l = match l with Nil -> 0 | List (_,l') -> 1 + mylength l';;")]),t._v(" "),a("ul",[a("li",[t._v("mylength (List (1, List (2, Nil)));;"),a("br"),t._v(" int = 2")])])])]),t._v(" "),a("h2",{attrs:{id:"exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exceptions"}},[t._v("#")]),t._v(" Exceptions")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("exception은 run-time error를 의미한다.")]),t._v(" "),a("ul",[a("li",[t._v("ex) let div a b = a / b;; "),a("br"),t._v(" div 10 0;;"),a("br"),t._v("(Exception: Division_by_zero)")])])]),t._v(" "),a("li",[a("p",[t._v("이를 다룰 수 있음.")]),t._v(" "),a("ul",[a("li",[t._v("let div a b = "),a("B",[t._v("try a/b with Division_by_zero -> 0;;")])],1),t._v(" "),a("li",[t._v("div 10 0;; (int = 0)")])])]),t._v(" "),a("li",[a("p",[t._v("직접 exception problem을 정의 가능")]),t._v(" "),a("ul",[a("li",[t._v("let div a b = if b = 0 then "),a("B",[t._v("raise Problem")]),t._v(" else a / b;;")],1),t._v(" "),a("li",[t._v("div 10 0;; (Exception: Problem)")])])])])])}),[],!1,null,null,null);e.default=l.exports}}]);